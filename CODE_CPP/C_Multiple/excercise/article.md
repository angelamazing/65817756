<!--
 * @Author: your name
 * @Date: 2021-09-02 14:34:18
 * @LastEditTime: 2021-09-02 14:34:18
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \C_Multiple\excercise\article.md
-->

1. 专用名词
（1）二义性调用（ambiguous call）是一种编译时发生的错误，造成二义性调用的原因是在函数匹配时两个或多个函数匹配一样好，编译器找不到唯一的最佳匹配。
（2）候选函数（candidate function）解析某次函数调用时考虑的一组函数。候选函数的名字婴孩与函数调用使用的名字一致，并且在调用点候选函数的声明在作用域之内。
（3）函数匹配（function matching）编译器解析重载函数调用的过程，在此过程中，实参与每个重载函数的形参列表逐一比较。
（4）可行函数（viable function）是候选函数的子集。可行函数能匹配本次调用，它的形参数量与调用提供的实参数量相等，并且每个实参类型都能够转换成相应的形参类型。
（5）最佳匹配（best match）从一组重载函数中选出一个函数。如果存在最佳匹配，则选出的函数与其他所有可行函数相比，至少在一个实参上是更优的匹配，同时在其他实参的匹配上不会更差。
（6）实参（argument）函数调用时提供的值，用于初始化函数的形参。
（7）局部变量（local variable）定义在快中的变量。
（8）形参（parameter）在函数的形参列表中声明的局部变量。用实参初始化形参。
（9）自动对象（automatic object）仅存在与函数执行过程中的对象。当程序的控制流经过此类对象的定义语句时，创建该对象；当到达了定义所在的块的末尾时，销毁该对象。
（10）局部静态对象（local static object）它的值在函数调用结束后仍然存在。在第一次使用局部静态对象前创建并初始化它，当程序结束时局部静态对象才被销毁。
（11）函数（function）可调用的计算单元。它对程序的结构化至关重要。每个函数都包含返回类型、名字、（可能为空）形参列表以及函数体。函数体是一个块，当函数被调用的时候执行该块的内容。此时，传递给函数的实参类型必须与对应的形参类型相容。
（12）函数原型（function prototype）函数的声明，包含函数名字、返回类型和形参类型。要想调用某函数，在调用点之前必须声明该函数的原型。
（13）内联函数（inline function）请求编译器在可能的情况下在调用点展开函数。内联函数可以避免常见的函数调用开销。
（14）constexpr  可以返回常量表达式的函数，一个constexpr函数被隐式地声明成内联函数。
（15）默认实参（default argument）当调用缺少了某个实参时，为该实参指定的默认值。
（16）隐藏名字（hidden name）某个作用域内声明的名字会隐藏掉外层作用域中声明的同名实体。
（17）intializer_list  是一个标准类，表示的是一组花括号包围的类型相同的对象，对象之间以逗号隔开。
（18）重载函数（overloaded function）函数名与其他函数相同的函数。多个重载函数必须在形参数量或形参类型上有所区别。
（19）引用传递（pass by reference）描述如何将实参传递给引用类型的形参。引用形参和其他形式的引用工作机理相似，形参被绑定到相应的实参上。
（20）值传递（pass by value）描述如何将实参传递给非引用类型的形参。非引用类型的形参实际上是相应实参值的一个副本。
（21）递归函数（recursive function）直接或间接调用自身的函数。
（22）递归循环（recursion loop）描述某个递归函数没有终止条件，因而不断调用自身直至耗尽程序栈空间的过程。
（23）对象生命周期（object lifetime）每个对象都有相应的生命周期。块内定义的非静态对象的生命周期从它的定义开始，到定义所在的块末尾为止。程序启动后创建全局对象，程序控制流经过局部静态对象的定义时创建该局部静态对象；当main函数结束时销毁全局对象和局部静态对象。
（24）分离式编译（separate compilation）把一个程序分割成多个独立的源文件的能力。
（25）尾置返回类型（trailing return type）在参数列表后面指定的返回类型。在本该出现返回类型的位置放置一个auto。
例如：// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组

          auto func(int i) -> int(*)[10];

（26）对象代码（object code）编译器将我们的源代码转换成对象代码的格式。
（27）对象文件（object file）编译器根据给定的源文件生成的保存对象代码的文件。一个或多个对象文件经过链接生成可执行文件。
（28）链接（link）是一个编译过程，负责把若干对象文件链接起来形成可执行程序。
（29）可执行文件（executable file）是操作系统能够执行的文件，包含着与程序有关的代码。
（30）无匹配（no match）是一种编译时发生的错误，原因是在函数匹配过程中所有函数的形参都不能与调用提供的实参匹配。
