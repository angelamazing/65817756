<!--
 * @Author: your name
 * @Date: 2021-08-26 11:34:44
 * @LastEditTime: 2021-08-28 16:47:28
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \C_Multiple\excercise\chapter12 statement\article.md
-->
# 1声明

1. 语法
    声明说明符 声明符
    1. 声明说明符
        1. 存储类型 auto static extern register
        2. 类型限定符   const volatile `附加属性`
        3. 类型说明符   void char short ... `类型,决定占有空间及映射方法`

        extern const unsigned int a[10];
    2. 声明符:标识符

2. 存储类型
    1. 变量的3个特性
        1. 存储期限
        2. 作用域
        3. 链接 确定了程序的不同部分可以共享此变量的范围
            外部链接: 变量可以被程序的几个文件共享
            内部链接: 变量只能属于单独一个文件,但是此文件中的函数可以共享这个变量
            无链接: 只属于单独一个函数
        变量的默认特性取决于变量声明的位置
        1. 在块内部:自动存储期,块作用域,无链接
        2. 在程序最外层:静态存储期,文件作用域,外部链接
    2. auto
        只对块作用域的变量起作用,具有:自动,块作用,无链接
    3. static
        可以用于全部变量
        但是块外部 和 块内部有所不同
        1. 块内部: 静态存储期,块作用域,无链接
            块内声明的static变量在程序执行期间`驻留`在同一存储单元,和每次程序离开块就会丢失的`自动变量`不同,static变量会无限期保留值.
            有趣的性质:
            1. 块内的static变量只在程序执行前进行一次初始化,而auto变量会在每次变为有效时进行初始化.
            2. 每次函数进行递归调用时,会形成一组新的auto变量的集合.
                然而对于static变量,全体共享
            3. 函数虽然不能返回auto变量的指针,但是函数`返回static变量的指针`是没有错误的.
        2. 块外部: 静态存储期,文件作用,内部链接
            在用于块外部声明时,static本质上隐藏了它所在声明文件内的变量,只有出现在同一文件中的函数才可以看到此变量.
            static此类用法可以用来实现 一种叫做 `信息隐藏` 的技术
    4. extern
        1. 块内部声明
            静态存储,文件作用
        2. 块外部声明
            静态存储,块作用域
        变量在文件较早的位置(任何函数定义的外部)声明为static,则具有内部链接
        否则,具有外部链接
    5. register
        只对声明在块内的变量有效
        同auto变量具有一样的存储期,作用域,链接
        但是由于寄存器没有地址,所以对register变量取地址是无效的
        最好用于需要频繁访问的或更新的变量
        例如在for语句中
        register int i;
        for(i=0;i < n;i++)
            sum+=a[i];
        但是现在一些编译器可以自动决定变量是否保留在寄存器中以获得最大的好处
    6. 函数的存储类型
        只有 extern static
        如果指明static,只有在定义函数的文件内部可以调用此函数
        不指明,就默认为extern
        但是呢,把函数声明为static有如下好处:
        1. 容易维护
            开发人员对static函数进行修改知道不会影响其他文件的函数
            一个例外就是:另一个文件的函数如果传递了该函数的指针可能会受到该函数的影响,不过这种问题很容易检查出来.
        2. 减少了`名字空间污染`

3. 类型限定符
    1. const
        1. 文档格式
        2. 嵌入式开发存储到ROM中
        3. 与宏定义区别:①#define只能生产数字常量,字符常量,字符串常量的名字
                        ②const类型常量遵循与变量相同的作用域规则
                        ③可以在调试器看到const对象的值
                        ④不同于宏,不可以把const对象用于常量表达式
                        const int n =10;
                        int a[n];   //这是错误的

4. 声明符
    是由 `标识符` 和 前边的符号`*` 后边的符号`[] ()`构成的
    *为指针,[]表示数组,()表示函数
    例如:
    int *ap[10];    //10个指向整数的`指针`
    float *fp(float);    //此函数返回float型指针
    void (*pf)(int);    //指向一个函数的指针,这个函数:int型参数,返回void值
    1. 解释复杂声明
    int *(*x[10])(void);
    两条规则:始终`从内向外`读声明符, 在做选择时始终先`[]`后`()`最后是`*`
        void (*pf)(int) //一个指向函数的指针
    错误的返回:
        int f(int)[];   //函数不能返回数组
        int g(int)(int);//函数不能返回函数
        int a[10] (int); //函数型的数组也可行

5. 使用类型定义简化声明

6. 初始化式
    1. `数组,联合,结构`的初始化式通常是一串封闭在`大括号的值`
        int a[5] = {1,2,3,4,5};
    2. 静态存储变量初始化式必须是常量
    3. 自动存储变量初始化式不必须是常量
    4. 用大括号闭合的`数组,联合,结构`初始化式必须只能包含常量表达式,不允许变量和函数调用
    5. 针对`自动类型的结构或者联合`,它的初始化式可以是另外一个结构或联合
        void g(struct complex c1)
        {
            struct complex c2 = c1;
            ...
        }

7. 未初始化的变量
    1. 自动类型变量没有默认初始值
    2. 静态存储变量默认为0
        不同于calloc分配的内存是简单 指定字节的位置零,而静态变量是基于类型的正确初始化
        即整型初始化为0,浮点初始化为0.0,指针初始化为nullptr

8. 重要问题
    1. 作用域得益于编译器
        链接得益于链接器
    2. const对象只是在它生命周期保持常量
        在块外边声明的const对象具有外部链接,在文件间共享,很容易出现:
        extern const int n;
        int a[n];   //wrong
    
# 2程序设计

1. 模块
2. 接口
3. 实现
4. 抽象 可复用性  可维护性

5. 内聚性
    耦合性

6. 模块的类型
    1. 数据池
    2. 抽象对象
    3. 抽象数据类型
    4. 库

7. 信息隐藏
    1. 安全性
    2. 灵活性
    接口 与 实现细节

8. 抽象数据类型
    c语言没有设计专门用于封装的特性
    这里就出现了c++